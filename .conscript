import os, shutil, sys, subprocess, select, signal, termios, tty
Import("env")

img_file      = "bareOS.img"

def error(code, msg):
    print(msg)
    Exit(code)
dirs = ("system", "device", "app", "lib")
kernel_files  = [Glob(os.path.join("kernel", d, "*.[cs]")) for d in dirs]
def do_gdb(target, source, env):
    gdb_file = img_file
    os.system(f'{env["GDB"]} -ex "file {gdb_file}" -ex "target remote :{env["port"]}"')
    env.Exit(0)

bld_gdb = env.Builder(action=do_gdb)
env["BUILDERS"]["GDB"] = bld_gdb

def do_qemu(target, source, env):
    env['qflags'] += f" -S -gdb tcp::{env['port']}"

bld_qemu = env.Builder(action=do_qemu)
env["BUILDERS"]["Qemu"] = bld_qemu

# ----------------------  Build OS Image  ----------------------------
objs   = env.Object(kernel_files)
img    = env.Program(img_file, objs)
img    = env.Command(None, img, Copy(img_file, "$SOURCE"))
env.Alias("gdb", objs)

env.Alias("build", img)
# ----------------------  Virtualization  ----------------------------
if "debug" in COMMAND_LINE_TARGETS:
    env['qflags'] += f" -S -gdb tcp::{env['port']}"

def run_qemu(target, source, env):
    args = [env['QEMU'], '-kernel', str(source[0])] + env['qflags'].split()
    proc = subprocess.Popen(
        args,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        bufsize=0,
    )
    shutdown_msg = b"The system will shut down now."
    buf = b""
    fd = sys.stdin.fileno()
    old = termios.tcgetattr(fd)
    tty.setcbreak(fd)
    try:
        while True:
            rlist, _, _ = select.select([proc.stdout, sys.stdin], [], [])
            if proc.stdout in rlist:
                data = os.read(proc.stdout.fileno(), 1024)
                if not data:
                    break
                os.write(sys.stdout.fileno(), data)
                buf += data
                if shutdown_msg in buf:
                    proc.terminate()
                buf = buf[-len(shutdown_msg):]
            if sys.stdin in rlist:
                inp = os.read(fd, 1024)
                if not inp:
                    break
                os.write(proc.stdin.fileno(), inp)
            if proc.poll() is not None:
                break
    except KeyboardInterrupt:
        proc.send_signal(signal.SIGINT)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old)
        proc.wait()
    return 0

run = env.Command(target="run_cmd", source=img_file, action=run_qemu)
env.Depends(run, img)
env.Alias("run", run)


# --------------------  Environment Management  ----------------------



env.Clean(img, env["memmap"])
env.Clean(img, f"#{img_file}")
