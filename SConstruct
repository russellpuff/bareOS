import os, random, shutil, re

try:
    # Remove '' target if present
    if "" in COMMAND_LINE_TARGETS:
        print("[Info] '' target has been removed; ignoring it.")
        COMMAND_LINE_TARGETS[:] = [t for t in COMMAND_LINE_TARGETS if t != ""]
except Exception:
    pass

try:
    # Disable 'build' target
    if "build" in COMMAND_LINE_TARGETS:
        print("[Warning] 'build' target is disabled. Use `scons run`.")
        Exit(1)
except Exception:
    pass

# pseudo-constants for loading files, grabs from fs.h in case the ramdisk is changed
fs_header = os.path.join("kernel", "include", "fs.h")
with open(fs_header) as f:
    fs_src = f.read()

def _const(name):
    m = re.search(r"#define\s+%s\s+(\d+)" % name, fs_src)
    if not m:
        raise ValueError(f"{name} not found in fs.h")
    return int(m.group(1))

INODE_BLOCKS = _const("INODE_BLOCKS")
BLOCK_SIZE = _const("MDEV_BLOCK_SIZE")
FILENAME_LEN = _const("FILENAME_LEN")
DIR_SIZE = _const("DIR_SIZE")
MAX_FILE_SIZE = INODE_BLOCKS * BLOCK_SIZE
HEADER_SIZE = FILENAME_LEN + 16
START_ADDR = 0x8003bb90 + 24 # start of heap + sizeof(alloc_t), kernel.ld hardcodes available memory so this won't change unless I change it


def do_name_bytes(stem: str) -> bytes:
    b = stem.encode('utf-8')
    if len(stem) > FILENAME_LEN:
        return None
    return b[:FILENAME_LEN].ljust(FILENAME_LEN, b'\x00')

def do_size_bytes(size: int) -> bytes:
    return int(size).to_bytes(16, 'little')

Help("""
usage: scons command
       scons -c
       scons -h

options:
  -c, --clean   Remove all files generated by previous builds.

description: SCons entry points.

Commands:
  build
    usage: scons [build]
    description: (Disabled) Relied on obsolete testutils.c.

  run
    usage: scons run [debug] [port=PORT]

    options:
      PORT   When running `debug`, use port=PORT to specify a different port.
""")

has_gnu = shutil.which("riscv64-unknown-linux-gnu-gcc")
arch   = ARGUMENTS.get('arch', "riscv64-unknown-linux-gnu" if has_gnu is not None else "riscv64-unknown-elf")
builder   = ".conscript"
build_dir = ".build"
inc_dir   = os.path.join("kernel", "include")
ld_file   = os.path.join("kernel", "kernel.ld")
map_file  = File(os.path.join(build_dir, "kernel.map"))

PORT = ARGUMENTS.get("port", random.Random(os.environ["USER"]).randint(5570, 7000))
logfile = ARGUMENTS.get("logfile", "")
logfile = f",logfile={logfile}" if logfile else ""

CC     = "-".join([arch, "gcc"])
cflags = "-std=gnu2x -Wall -Werror -fno-builtin -nostdlib -nostdinc -march=rv64imac_zicsr -mabi=lp64 -mcmodel=medany -O0 -g "
LD     = "-".join([arch, "ld"])
lflags = f"-nostdlib -Map {map_file} -T {ld_file} "
AS     = "-".join([arch, "as"])
aflags = "-march=rv64imac_zicsr -mabi=lp64 -g "
QEMU   = "qemu-system-riscv64"
qflags = f"-M virt -bios none -m 128M -chardev stdio,id=uart0{logfile} -serial chardev:uart0 -display none "
GDB    = "-".join([arch, "gdb"])

#Load user filess from /load, this is attached to qflags

current = START_ADDR
LOAD_DIR = 'load'
files = sorted(
    f for f in os.listdir(LOAD_DIR)
    if os.path.isfile(os.path.join(LOAD_DIR, f))
    and not f.endswith('.header')
)[:DIR_SIZE]

total_bytes = 0

for f in files:
    stem = os.path.splitext(f)[0]
    name_bytes = do_name_bytes(stem)
    if name_bytes is None:
        continue

    path = os.path.join(LOAD_DIR, f)
    f_size = os.path.getsize(path)
    if f_size > MAX_FILE_SIZE:
        continue

    header_path = os.path.join(LOAD_DIR, stem + ".header")

    # Force rewrite header.
    header = name_bytes + do_size_bytes(f_size)
    assert len(header) == HEADER_SIZE
    with open(header_path, 'wb') as hf:
        hf.write(header)

    # load header
    qflags += f"-device loader,file={header_path},addr=0x{current:08x} "
    current += HEADER_SIZE
    # load file
    qflags += f"-device loader,file={path},addr=0x{current:08x} "
    current += f_size
    total_bytes += HEADER_SIZE + f_size

print(qflags)

env = Environment(CC=CC, AS=AS, LINK=LD, QEMU=QEMU, GDB=GDB, CPPPATH=inc_dir, LINKFLAGS=lflags, memmap=map_file, qflags=qflags, port=PORT)
env.Append(ENV={"PATH": os.environ["PATH"]}, CFLAGS=cflags, ASFLAGS=aflags)
script = env.SConscript(builder, variant_dir=build_dir, duplicate=0, exports='env')
