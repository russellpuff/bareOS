import os, random, shutil

# constants for loading files
INODE_BLOCKS = 12
BLOCK_SIZE = 512
MAX_NAME_LENGTH = 16
MAX_FILE_SIZE = INODE_BLOCKS * BLOCK_SIZE
HEADER_SIZE = 32
START_ADDR = 0x84000000

def do_name_bytes(stem: str) -> bytes:
    b = stem.encode('utf-8')
    if len(stem) > MAX_NAME_LENGTH:
        return None
    return b[:MAX_NAME_LENGTH].ljust(MAX_NAME_LENGTH, b'\x00')

def do_size_bytes(size: int) -> bytes:
    return int(size).to_bytes(16, 'little')

Help("""
usage: scons command
       scons -c

options:
  -c, --clean   Remove all of the files generated by previous builds.  This
                acts as a hard reset in the case were the build tools ever
                fail to compile the most recent copy of your files.

description: Runs the scons build tools. 

Commands:
  checkout
      usage: scons checkout milestone=MILESTONE
      
      options:
        MILESTONE   A number between 1 and 10

      description: Checks out the code  necessary for a requested milestone
                   if the file already exists, you will be prompted to keep
                   or replace the file.

  build
    usage: scons [build]
    
    descrption: Builds the image from the source files.  This command will
                build two  products, a  `bareOS.img` and `tests.img` which
                are used by the `run` and `test` commands respectively.

  run
    usage: scons run [debug] [port=PORT]

    options:
      PORT   When  running  `debug`, a network  connection is  required.
             sometimes  this  connection  is already  in use  by another
             application.   Set  the  port  to  specifically  request  a
             differet port (this option  SHOULD NOT be necessary in most
             cases).

    description: Runs the `bareOS.img` file in the QEMU virtual machine.
                 If the `bareOS.img`  file doesn't exist, it will  first
                 run `scons build` automatically.

                 If  the `debug`  command  is also  included,  QEMU will
                 instead  start, but  wait on a gdb  session to connect.
                 (See `scons gdb`)

  test
    usage: scons test [debug] [milestone=MILESTONE] [port=PORT]

    options:
      MILESTONE   A number  between 1 and 10 indicating the milestone to
                  test.  If no  milestone is  provided, the  script will
                  attempt to determine it automatically.

      PORT   When  running  `debug`, a network  connection is  required.
             sometimes  this  connection  is already  in use  by another
             application.   Set  the  port  to  specifically  request  a
             differet port (this option  SHOULD NOT be necessary in most
             cases).

    description: Run  the  `tests.img`  file in  QEMU  virtual  machine.
                 This will display the output of  custom unit tests that
                 examine the implementation of the requested milestone.

                 If  the `debug`  command  is also  included,  QEMU will
                 instead  start, but  wait on a gdb  session to connect.
                 (See `scons gdb`)

  gdb
    usage: scons gdb [port=PORT]

    options:
      PORT   This  port MUST  match the  port  used in the  run or test
             command.  If no port was  used in the run or test  command
             this options should not be used.

    description: Starts a  gdb  debugging  session with  the  currently
                 running  kernel.  This will allow  you to step through
                 your kernel line by line using the gnu debugger.
""")

has_gnu = shutil.which("riscv64-unknown-linux-gnu-gcc")
arch   = ARGUMENTS.get('arch', "riscv64-unknown-linux-gnu" if has_gnu is not None else "riscv64-unknown-elf")
builder   = ".conscript"
build_dir = ".build"
inc_dir   = os.path.join("kernel", "include")
ld_file   = os.path.join("kernel", "kernel.ld")
map_file  = File(os.path.join(build_dir, "kernel.map"))

PORT = ARGUMENTS.get("port", random.Random(os.environ["USER"]).randint(5570, 7000))
logfile = ARGUMENTS.get("logfile", "")
logfile = f",logfile={logfile}" if logfile else ""

CC     = "-".join([arch, "gcc"])
cflags = "-std=gnu2x -Wall -Werror -fno-builtin -nostdlib -nostdinc -march=rv64imac_zicsr -mabi=lp64 -mcmodel=medany -O0 -g "
LD     = "-".join([arch, "ld"])
lflags = f"-nostdlib -Map {map_file} -T {ld_file} "
AS     = "-".join([arch, "as"])
aflags = "-march=rv64imac_zicsr -mabi=lp64 -g "
QEMU   = "qemu-system-riscv64"
qflags = f"-M virt -bios none -m 256M -chardev stdio,id=uart0{logfile} -serial chardev:uart0 -display none "
GDB    = "-".join([arch, "gdb"])

#Load user filess from /load, this is attached to qflags

current = START_ADDR
LOAD_DIR = 'load'
files = sorted(
    f for f in os.listdir(LOAD_DIR)
    if os.path.isfile(os.path.join(LOAD_DIR, f))
    and not f.endswith('.header')
)

for f in files:
    name_bytes = do_name_bytes(os.path.splitext(f)[0])
    if name_bytes is None:
        continue
    path = os.path.join(LOAD_DIR, f)
    f_size = os.path.getsize(path)
    if f_size > MAX_FILE_SIZE:
        continue
    header_name = os.path.splitext(os.path.basename(f))[0] + ".header"
    header_path = os.path.join(LOAD_DIR, header_name)
    if not os.path.exists(header_path): # create header file if it doesn't exist, reuse old (fix later)
        with open(header_path, 'wb') as hf:
            hf.write(name_bytes + do_size_bytes(f_size))
    # write header
    qflags += f"-device loader,file={header_path},addr=0x{current:08x} "
    current += HEADER_SIZE
    # write file
    qflags += f"-device loader,file={path},addr=0x{current:08x} "
    current += f_size



env = Environment(CC=CC, AS=AS, LINK=LD, QEMU=QEMU, GDB=GDB, CPPPATH=inc_dir, LINKFLAGS=lflags, memmap=map_file, qflags=qflags, port=PORT)
if not any([env.GetOption(c) for c in ["clean", "help"]]):
    try:
        env["milestone"] = ARGUMENTS["milestone"]
    except KeyError:
        if "checkout" in COMMAND_LINE_TARGETS:
            error(-1 ,"[Error] Cannot checkout code without explicit `milestone=#` argument")
        try:
            with open(".msfile", 'r') as f:
                env["milestone"] = ARGUMENTS.get("milestone", f.read().split('\n')[0])
        except OSError as exp:
            print(exp)
            error(-1, """[Error] Cannot determine milestone, run `scons checkout milestone=#`
            or include an explicit `milestone=#` in the command")""")
else:
    env["milestone"]="0"

env.Append(ENV={"PATH": os.environ["PATH"]}, CFLAGS=cflags, ASFLAGS=aflags)
script = env.SConscript(builder, variant_dir=build_dir, duplicate=0, exports='env')
